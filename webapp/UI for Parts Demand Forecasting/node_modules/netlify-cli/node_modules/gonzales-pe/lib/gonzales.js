(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gonzales"] = factory();
	else
		root["gonzales"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(1);
	var parse = __webpack_require__(7);

	module.exports = {
	  createNode: function createNode(options) {
	    return new Node(options);
	  },
	  parse: parse
	};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * @param {string} type
	 * @param {array|string} content
	 * @param {number} line
	 * @param {number} column
	 * @constructor
	 */

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Node = function () {
	  function Node(options) {
	    _classCallCheck(this, Node);

	    this.type = options.type;
	    this.content = options.content;
	    this.syntax = options.syntax;

	    if (options.start) this.start = options.start;
	    if (options.end) this.end = options.end;
	  }

	  /**
	   * @param {String} type Node type
	   * @return {Boolean} Whether there is a child node of given type
	   */


	  Node.prototype.contains = function contains(type) {
	    if (!Array.isArray(this.content)) {
	      return false;
	    }

	    return this.content.some(function (node) {
	      return node.type === type;
	    });
	  };

	  /**
	   * @param {String} type Node type
	   * @param {Function} callback Function to call for every found node
	   */


	  Node.prototype.eachFor = function eachFor(type, callback) {
	    if (!Array.isArray(this.content)) return;

	    if (typeof type !== 'string') {
	      callback = type;
	      type = null;
	    }

	    var l = this.content.length;
	    var breakLoop;

	    for (var i = l; i--;) {
	      if (breakLoop === null) break;

	      if (!type || this.content[i] && this.content[i].type === type) breakLoop = callback(this.content[i], i, this);
	    }

	    if (breakLoop === null) return null;
	  };

	  /**
	   * @param {String} type
	   * @return {?Node} First child node or `null` if nothing's been found.
	   */


	  Node.prototype.first = function first(type) {
	    if (!Array.isArray(this.content)) return null;

	    if (!type) return this.content[0];

	    var i = 0;
	    var l = this.content.length;

	    for (; i < l; i++) {
	      if (this.content[i].type === type) return this.content[i];
	    }

	    return null;
	  };

	  /**
	   * @param {String} type Node type
	   * @param {Function} callback Function to call for every found node
	   */


	  Node.prototype.forEach = function forEach(type, callback) {
	    if (!Array.isArray(this.content)) return;

	    if (typeof type !== 'string') {
	      callback = type;
	      type = null;
	    }

	    var i = 0;
	    var l = this.content.length;
	    var breakLoop;

	    for (; i < l; i++) {
	      if (breakLoop === null) break;

	      if (!type || this.content[i] && this.content[i].type === type) breakLoop = callback(this.content[i], i, this);
	    }

	    if (breakLoop === null) return null;
	  };

	  /**
	   * @param {Number} index
	   * @return {?Node}
	   */


	  Node.prototype.get = function get(index) {
	    if (!Array.isArray(this.content)) return null;

	    var node = this.content[index];
	    return node ? node : null;
	  };

	  /**
	   * @param {Number} index
	   * @param {Node} node
	   */


	  Node.prototype.insert = function insert(index, node) {
	    if (!Array.isArray(this.content)) return;

	    this.content.splice(index, 0, node);
	  };

	  /**
	   * @param {String} type
	   * @return {Boolean} Whether the node is of given type
	   */


	  Node.prototype.is = function is(type) {
	    return this.type === type;
	  };

	  /**
	   * @param {String} type
	   * @return {?Node} Last child node or `null` if nothing's been found.
	   */


	  Node.prototype.last = function last(type) {
	    if (!Array.isArray(this.content)) return null;

	    var i = this.content.length;
	    if (!type) return this.content[i - 1];

	    for (; i--;) {
	      if (this.content[i].type === type) return this.content[i];
	    }

	    return null;
	  };

	  /**
	   * Number of child nodes.
	   * @type {number}
	   */


	  /**
	   * @param {Number} index
	   * @return {Node}
	   */
	  Node.prototype.removeChild = function removeChild(index) {
	    if (!Array.isArray(this.content)) return;

	    var removedChild = this.content.splice(index, 1);

	    return removedChild;
	  };

	  Node.prototype.toJson = function toJson() {
	    return JSON.stringify(this, false, 2);
	  };

	  Node.prototype.toString = function toString() {
	    var stringify = void 0;

	    try {
	      stringify = __webpack_require__(2)("./" + this.syntax + '/stringify');
	    } catch (e) {
	      var message = 'Syntax "' + this.syntax + '" is not supported yet, sorry';
	      return console.error(message);
	    }

	    return stringify(this);
	  };

	  /**
	   * @param {Function} callback
	   */


	  Node.prototype.traverse = function traverse(callback, index) {
	    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	    var breakLoop;
	    var x;

	    level++;

	    callback(this, index, parent, level);

	    if (!Array.isArray(this.content)) return;

	    for (var i = 0, l = this.content.length; i < l; i++) {
	      breakLoop = this.content[i].traverse(callback, i, level, this);
	      if (breakLoop === null) break;

	      // If some nodes were removed or added:
	      if (x = this.content.length - l) {
	        l += x;
	        i += x;
	      }
	    }

	    if (breakLoop === null) return null;
	  };

	  Node.prototype.traverseByType = function traverseByType(type, callback) {
	    this.traverse(function (node) {
	      if (node.type === type) callback.apply(node, arguments);
	    });
	  };

	  Node.prototype.traverseByTypes = function traverseByTypes(types, callback) {
	    this.traverse(function (node) {
	      if (types.indexOf(node.type) !== -1) callback.apply(node, arguments);
	    });
	  };

	  _createClass(Node, [{
	    key: 'length',
	    get: function get() {
	      if (!Array.isArray(this.content)) return 0;
	      return this.content.length;
	    }
	  }]);

	  return Node;
	}();

	module.exports = Node;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./css/stringify": 3,
		"./less/stringify": 4,
		"./sass/stringify": 5,
		"./scss/stringify": 6
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 2;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) {
	      s += _t(t[i]);
	    }return s;
	  }

	  var _unique = {
	    'arguments': function _arguments(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function atkeyword(t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function attributeSelector(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function block(t) {
	      return '{' + _composite(t.content) + '}';
	    },
	    'brackets': function brackets(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function _class(t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function color(t) {
	      return '#' + t.content;
	    },
	    'customProperty': function customProperty(t) {
	      return '--' + t.content;
	    },
	    'expression': function expression(t) {
	      return 'expression(' + t.content + ')';
	    },
	    'id': function id(t) {
	      return '#' + _composite(t.content);
	    },
	    'multilineComment': function multilineComment(t) {
	      return '/*' + t.content + '*/';
	    },
	    'nthSelector': function nthSelector(t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function parentheses(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function percentage(t) {
	      return _composite(t.content) + '%';
	    },
	    'pseudoClass': function pseudoClass(t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function pseudoElement(t) {
	      return '::' + _composite(t.content);
	    },
	    'universalSelector': function universalSelector(t) {
	      return _composite(t.content) + '*';
	    },
	    'uri': function uri(t) {
	      return 'url(' + _composite(t.content) + ')';
	    }
	  };

	  return _t(tree);
	};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) {
	      s += _t(t[i]);
	    }return s;
	  }

	  var _unique = {
	    'arguments': function _arguments(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function atkeyword(t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function attributeSelector(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function block(t) {
	      return '{' + _composite(t.content) + '}';
	    },
	    'brackets': function brackets(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function _class(t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function color(t) {
	      return '#' + t.content;
	    },
	    'escapedString': function escapedString(t) {
	      return '~' + t.content;
	    },
	    'expression': function expression(t) {
	      return 'expression(' + t.content + ')';
	    },
	    'id': function id(t) {
	      return '#' + _composite(t.content);
	    },
	    'interpolatedVariable': function interpolatedVariable(t) {
	      return '@{' + _composite(t.content) + '}';
	    },
	    'multilineComment': function multilineComment(t) {
	      return '/*' + t.content + '*/';
	    },
	    'nthSelector': function nthSelector(t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function parentheses(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function percentage(t) {
	      return _composite(t.content) + '%';
	    },
	    'pseudoClass': function pseudoClass(t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function pseudoElement(t) {
	      return '::' + _composite(t.content);
	    },
	    'singlelineComment': function singlelineComment(t) {
	      return '/' + '/' + t.content;
	    },
	    'universalSelector': function universalSelector(t) {
	      return _composite(t.content) + '*';
	    },
	    'uri': function uri(t) {
	      return 'url(' + _composite(t.content) + ')';
	    },
	    'variable': function variable(t) {
	      return '@' + _composite(t.content);
	    },
	    'variablesList': function variablesList(t) {
	      return _composite(t.content) + '...';
	    }
	  };

	  return _t(tree);
	};

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) {
	      s += _t(t[i]);
	    }return s;
	  }

	  var _unique = {
	    'arguments': function _arguments(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function atkeyword(t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function attributeSelector(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function block(t) {
	      return _composite(t.content);
	    },
	    'brackets': function brackets(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function _class(t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function color(t) {
	      return '#' + t.content;
	    },
	    'customProperty': function customProperty(t) {
	      return '--' + t.content;
	    },
	    'expression': function expression(t) {
	      return 'expression(' + t.content + ')';
	    },
	    'functionsList': function functionsList(t) {
	      return _composite(t.content) + '...';
	    },
	    'id': function id(t) {
	      return '#' + _composite(t.content);
	    },
	    'interpolation': function interpolation(t) {
	      return '#{' + _composite(t.content) + '}';
	    },
	    'multilineComment': function multilineComment(t) {
	      var lines = t.content.split('\n');
	      var close = '';

	      if (lines.length > 1) {
	        var lastLine = lines[lines.length - 1];
	        if (lastLine.length < t.end.column) {
	          close = '*/';
	        }
	      } else if (t.content.length + 4 === t.end.column - t.start.column + 1) {
	        close = '*/';
	      }

	      return '/*' + t.content + close;
	    },
	    'nthSelector': function nthSelector(t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function parentheses(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function percentage(t) {
	      return _composite(t.content) + '%';
	    },
	    'placeholder': function placeholder(t) {
	      return '%' + _composite(t.content);
	    },
	    'pseudoClass': function pseudoClass(t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function pseudoElement(t) {
	      return '::' + _composite(t.content);
	    },
	    'singlelineComment': function singlelineComment(t) {
	      return '/' + '/' + t.content;
	    },
	    'universalSelector': function universalSelector(t) {
	      return _composite(t.content) + '*';
	    },
	    'uri': function uri(t) {
	      return 'url(' + _composite(t.content) + ')';
	    },
	    'variable': function variable(t) {
	      return '$' + _composite(t.content);
	    },
	    'variablesList': function variablesList(t) {
	      return _composite(t.content) + '...';
	    }
	  };

	  return _t(tree);
	};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) {
	      s += _t(t[i]);
	    }return s;
	  }

	  var _unique = {
	    'arguments': function _arguments(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function atkeyword(t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function attributeSelector(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function block(t) {
	      return '{' + _composite(t.content) + '}';
	    },
	    'brackets': function brackets(t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function _class(t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function color(t) {
	      return '#' + t.content;
	    },
	    'customProperty': function customProperty(t) {
	      return '--' + t.content;
	    },
	    'expression': function expression(t) {
	      return 'expression(' + t.content + ')';
	    },
	    'functionsList': function functionsList(t) {
	      return _composite(t.content) + '...';
	    },
	    'id': function id(t) {
	      return '#' + _composite(t.content);
	    },
	    'interpolation': function interpolation(t) {
	      return '#{' + _composite(t.content) + '}';
	    },
	    'multilineComment': function multilineComment(t) {
	      return '/*' + t.content + '*/';
	    },
	    'nthSelector': function nthSelector(t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function parentheses(t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function percentage(t) {
	      return _composite(t.content) + '%';
	    },
	    'placeholder': function placeholder(t) {
	      return '%' + _composite(t.content);
	    },
	    'pseudoClass': function pseudoClass(t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function pseudoElement(t) {
	      return '::' + _composite(t.content);
	    },
	    'singlelineComment': function singlelineComment(t) {
	      return '/' + '/' + t.content;
	    },
	    'universalSelector': function universalSelector(t) {
	      return _composite(t.content) + '*';
	    },
	    'uri': function uri(t) {
	      return 'url(' + _composite(t.content) + ')';
	    },
	    'variable': function variable(t) {
	      return '$' + _composite(t.content);
	    },
	    'variablesList': function variablesList(t) {
	      return _composite(t.content) + '...';
	    }
	  };

	  return _t(tree);
	};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var ParsingError = __webpack_require__(8);
	var syntaxes = __webpack_require__(10);

	var isInteger = Number.isInteger || function (value) {
	  return typeof value === 'number' && Math.floor(value) === value;
	};

	/**
	 * @param {String} css
	 * @param {Object} options
	 * @return {Object} AST
	 */
	function parser(css, options) {
	  if (typeof css !== 'string') throw new Error('Please, pass a string to parse');else if (!css) return __webpack_require__(29)();

	  var syntax = options && options.syntax || 'css';
	  var context = options && options.context || 'stylesheet';
	  var tabSize = options && options.tabSize;
	  if (!isInteger(tabSize) || tabSize < 1) tabSize = 1;

	  var syntaxParser = syntaxes[syntax];

	  if (!syntaxParser) {
	    var message = 'Syntax "' + syntax + '" is not supported yet, sorry';
	    return console.error(message);
	  }

	  var getTokens = syntaxParser.tokenizer;
	  var mark = syntaxParser.mark;
	  var parse = syntaxParser.parse;

	  var tokens = getTokens(css, tabSize);
	  mark(tokens);

	  var ast;
	  try {
	    ast = parse(tokens, context);
	  } catch (e) {
	    if (!e.syntax) throw e;
	    throw new ParsingError(e, css);
	  }

	  return ast;
	}

	module.exports = parser;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var parserPackage = __webpack_require__(9);

	/**
	 * @param {Error} e
	 * @param {String} css
	 */
	function ParsingError(e, css) {
	  this.line = e.line;
	  this.syntax = e.syntax;
	  this.css_ = css;
	}

	ParsingError.prototype = {
	  /**
	   * @type {String}
	   * @private
	   */
	  customMessage_: '',

	  /**
	   * @type {Number}
	   */
	  line: null,

	  /**
	   * @type {String}
	   */
	  name: 'Parsing error',

	  /**
	   * @type {String}
	   */
	  syntax: null,

	  /**
	   * @type {String}
	   */
	  version: parserPackage.version,

	  /**
	   * @type {String}
	   */
	  get context() {
	    var LINES_AROUND = 2;

	    var result = [];
	    var currentLineNumber = this.line;
	    var start = currentLineNumber - 1 - LINES_AROUND;
	    var end = currentLineNumber + LINES_AROUND;
	    var lines = this.css_.split(/\r\n|\r|\n/);

	    for (var i = start; i < end; i++) {
	      var line = lines[i];
	      if (!line) continue;
	      var ln = i + 1;
	      var mark = ln === currentLineNumber ? '*' : ' ';
	      result.push(ln + mark + '| ' + line);
	    }

	    return result.join('\n');
	  },

	  /**
	   * @type {String}
	   */
	  get message() {
	    if (this.customMessage_) {
	      return this.customMessage_;
	    } else {
	      var message = 'Please check validity of the block';
	      if (typeof this.line === 'number') message += ' starting from line #' + this.line;
	      return message;
	    }
	  },

	  set message(message) {
	    this.customMessage_ = message;
	  },

	  /**
	   * @return {String}
	   */
	  toString: function toString() {
	    return [this.name + ': ' + this.message, '', this.context, '', 'Syntax: ' + this.syntax, 'Gonzales PE version: ' + this.version].join('\n');
	  }
	};

	module.exports = ParsingError;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = {"name":"gonzales-pe","description":"Gonzales Preprocessor Edition (fast CSS parser)","version":"4.3.0","homepage":"http://github.com/tonyganch/gonzales-pe","bugs":"http://github.com/tonyganch/gonzales-pe/issues","license":"MIT","author":{"name":"Tony Ganch","email":"tonyganch+github@gmail.com","url":"http://tonyganch.com"},"main":"./lib/gonzales","repository":{"type":"git","url":"http://github.com/tonyganch/gonzales-pe.git"},"scripts":{"autofix-tests":"bash ./scripts/build.sh && bash ./scripts/autofix-tests.sh","build":"bash ./scripts/build.sh","init":"bash ./scripts/init.sh","lint":"bash ./scripts/lint.sh","log":"bash ./scripts/log.sh","prepublishOnly":"bash ./scripts/build.sh","test":"bash ./scripts/test.sh","watch":"bash ./scripts/watch.sh"},"bin":{"gonzales":"./bin/gonzales.js"},"dependencies":{"minimist":"^1.2.5"},"devDependencies":{"babel-core":"^6.18.2","babel-loader":"^6.2.7","babel-plugin-add-module-exports":"^0.2.1","babel-preset-es2015":"^6.18.0","coffee-script":"~1.7.1","eslint":"^3.0.0","jscs":"2.1.0","jshint":"2.10.2","json-loader":"^0.5.3","mocha":"2.2.x","webpack":"^1.12.2","webpack-closure-compiler":"^2.0.2"},"engines":{"node":">=0.6.0"},"files":["MIT-LICENSE.txt","bin/gonzales.js","lib/gonzales.js"]}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  css: __webpack_require__(11),
	  less: __webpack_require__(17),
	  sass: __webpack_require__(21),
	  scss: __webpack_require__(25)
	};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.default = {
	  mark: __webpack_require__(12),
	  parse: __webpack_require__(14),
	  stringify: __webpack_require__(3),
	  tokenizer: __webpack_require__(16)
	};
	module.exports = exports['default'];

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var TokenType = __webpack_require__(13);

	/**
	 * Mark whitespaces and comments
	 * @param {Array} tokens
	 */
	function markSpacesAndComments(tokens) {
	  var tokensLength = tokens.length;
	  var spaces = [-1, -1];
	  var type; // Current token's type

	  // For every token in the token list, mark spaces and line breaks
	  // as spaces (set both `ws` and `sc` flags). Mark multiline comments
	  // with `sc` flag.
	  // If there are several spaces or tabs or line breaks or multiline
	  // comments in a row, group them: take the last one's index number
	  // and save it to the first token in the group as a reference:
	  // e.g., `ws_last = 7` for a group of whitespaces or `sc_last = 9`
	  // for a group of whitespaces and comments.
	  for (var i = 0; i < tokensLength; i++) {
	    type = tokens[i].type;

	    if (type === TokenType.Space || type === TokenType.Tab || type === TokenType.Newline) {
	      markSpace(tokens, i, spaces);
	    } else if (type === TokenType.CommentML) {
	      markComment(tokens, i, spaces);
	    } else {
	      markEndOfSpacesAndComments(tokens, i, spaces);
	    }
	  }

	  markEndOfSpacesAndComments(tokens, i, spaces);
	}

	function markSpace(tokens, i, spaces) {
	  var token = tokens[i];
	  token.ws = true;
	  token.sc = true;

	  if (spaces[0] === -1) spaces[0] = i;
	  if (spaces[1] === -1) spaces[1] = i;
	}

	function markComment(tokens, i, spaces) {
	  var ws = spaces[0];
	  tokens[i].sc = true;

	  if (ws !== -1) {
	    tokens[ws].ws_last = i - 1;
	    spaces[0] = -1;
	  }
	}

	function markEndOfSpacesAndComments(tokens, i, spaces) {
	  var ws = spaces[0];
	  var sc = spaces[1];
	  if (ws !== -1) {
	    tokens[ws].ws_last = i - 1;
	    spaces[0] = -1;
	  }
	  if (sc !== -1) {
	    tokens[sc].sc_last = i - 1;
	    spaces[1] = -1;
	  }
	}

	/**
	 * Pair brackets
	 * @param {Array} tokens
	 */
	function markBrackets(tokens) {
	  var tokensLength = tokens.length;
	  var ps = []; // Parentheses
	  var sbs = []; // Square brackets
	  var cbs = []; // Curly brackets
	  var t = void 0; // Current token

	  // For every token in the token list, if we meet an opening (left)
	  // bracket, push its index number to a corresponding array.
	  // If we then meet a closing (right) bracket, look at the corresponding
	  // array. If there are any elements (records about previously met
	  // left brackets), take a token of the last left bracket (take
	  // the last index number from the array and find a token with
	  // this index number) and save right bracket's index as a reference:
	  for (var i = 0; i < tokensLength; i++) {
	    t = tokens[i];
	    var type = t.type;

	    if (type